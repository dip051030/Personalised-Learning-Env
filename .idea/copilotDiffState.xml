<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/scrapper/save_to_local.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scrapper/save_to_local.py" />
              <option name="originalContent" value="import json&#10;from typing import Union&#10;&#10;from models.external_tools_apis import serp_api_tool&#10;from schemas import LearningState&#10;&#10;def serper_api_results_parser(state: LearningState) -&gt; dict:&#10;    &quot;&quot;&quot;&#10;    Parses the results from the SerpAPI tool based on the current learning state.&#10;&#10;    Args:&#10;        state (LearningState): The current learning state containing the topic and grade.&#10;&#10;    Returns:&#10;        dict: The search results retrieved from the SerpAPI tool.&#10;    &quot;&quot;&quot;&#10;    serpapi_search_results = serp_api_tool(&#10;        query=state.current_resource.topic + 'for grade ' + str(state.current_resource.grade))&#10;    return serpapi_search_results&#10;&#10;&#10;def save_to_local(data: Union[dict, list], file_path: str):&#10;    &quot;&quot;&quot;&#10;    Saves the provided data (dict or list) to a local JSON file.&#10;&#10;    Args:&#10;        data (dict or list): The data to be saved.&#10;        file_path (str): The path where the data will be saved.&#10;&#10;    Raises:&#10;        TypeError: If the data contains unsupported types for JSON serialization.&#10;    &quot;&quot;&quot;&#10;    if not isinstance(data, (dict, list)):&#10;        raise TypeError(&quot;Data must be a dict or a list to be saved as JSON.&quot;)&#10;    with open(file_path, mode='w', encoding='utf-8') as f:&#10;        json.dump(data, f, indent=4, ensure_ascii=False)" />
              <option name="updatedContent" value="import json&#10;import logging&#10;import os&#10;from typing import Union&#10;&#10;from models.external_tools_apis import serp_api_tool&#10;from schemas import LearningState&#10;&#10;logging.basicConfig(&#10;    level=logging.INFO,&#10;    format='%(asctime)s %(levelname)s [%(filename)s:%(lineno)d] %(levelname)s %(message)s',&#10;    datefmt='%Y-%m-%d %H:%M:%S'&#10;)&#10;&#10;def serper_api_results_parser(state: LearningState) -&gt; dict:&#10;    &quot;&quot;&quot;&#10;    Parses the results from the SerpAPI tool based on the current learning state.&#10;&#10;    Args:&#10;        state (LearningState): The current learning state containing the topic and grade.&#10;&#10;    Returns:&#10;        dict: The search results retrieved from the SerpAPI tool.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        serpapi_search_results = serp_api_tool(&#10;            query=state.current_resource.topic + ' for grade ' + str(state.current_resource.grade))&#10;        logging.info(f&quot;[save_to_local.py:{serper_api_results_parser.__code__.co_firstlineno}] INFO SerpAPI results parsed for topic '{state.current_resource.topic}' and grade '{state.current_resource.grade}'&quot;)&#10;        return serpapi_search_results&#10;    except Exception as e:&#10;        logging.error(f&quot;[save_to_local.py:{serper_api_results_parser.__code__.co_firstlineno}] ERROR Failed to parse SerpAPI results: {e}&quot;)&#10;        return {}&#10;&#10;def save_to_local(data: Union[dict, list], file_path: str):&#10;    &quot;&quot;&quot;&#10;    Saves the provided data (dict or list) to a local JSON file.&#10;&#10;    Args:&#10;        data (dict or list): The data to be saved.&#10;        file_path (str): The path where the data will be saved.&#10;&#10;    Raises:&#10;        TypeError: If the data contains unsupported types for JSON serialization.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        if not isinstance(data, (dict, list)):&#10;            raise TypeError(&quot;Data must be a dict or a list to be saved as JSON.&quot;)&#10;        dir_name = os.path.dirname(file_path)&#10;        if dir_name:&#10;            os.makedirs(dir_name, exist_ok=True)&#10;        with open(file_path, mode='w', encoding='utf-8') as f:&#10;            json.dump(data, f, indent=4, ensure_ascii=False)&#10;        logging.info(f&quot;[save_to_local.py:{save_to_local.__code__.co_firstlineno}] INFO Data saved to {file_path}&quot;)&#10;    except Exception as e:&#10;        logging.error(f&quot;[save_to_local.py:{save_to_local.__code__.co_firstlineno}] ERROR Failed to save data to {file_path}: {e}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/utils.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/utils.py" />
              <option name="updatedContent" value="import os&#10;import json&#10;import logging&#10;&#10;&#10;def save_learning_state_to_json(state, file_path):&#10;    &quot;&quot;&quot;&#10;    Save the details of the LearningState object to a JSON file.&#10;    If the file does not exist, it will be created.&#10;    Args:&#10;        state: LearningState object (should have .model_dump() or .dict() method)&#10;        file_path: Path to the JSON file&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Use model_dump if available (Pydantic v2), else fallback to dict&#10;        if hasattr(state, 'model_dump'):&#10;            state_data = state.model_dump()&#10;        elif hasattr(state, 'dict'):&#10;            state_data = state.dict()&#10;        else:&#10;            raise ValueError(&quot;State object does not support serialization.&quot;)&#10;        # Ensure the directory exists&#10;        os.makedirs(os.path.dirname(file_path), exist_ok=True)&#10;        with open(file_path, 'w', encoding='utf-8') as f:&#10;            json.dump(state_data, f, indent=4, ensure_ascii=False)&#10;        logging.info(f&quot;LearningState saved to {file_path}&quot;)&#10;    except Exception as e:&#10;        logging.error(f&quot;Failed to save LearningState to {file_path}: {e}&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>